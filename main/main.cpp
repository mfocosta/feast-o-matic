#include <stdio.h>
#include "Arduino.h"
#include "HX711.h"
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Stepper.h>
#include <WiFi.h>
#include "DHT.h"
#include "nvs.h"
#include "nvs_flash.h"
#include "esp_ota_ops.h"
#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"

/* Project includes */
#include "ota.h"
#include "mqtt.h"

static const char *TAG = "main_app";



// Configurações do DHT
#define DHTPIN 4      // Pino digital onde o DHT11 está ligado
#define DHTTYPE DHT11 // Tipo de sensor DHT

// Inicializa o sensor DHT
DHT dht(DHTPIN, DHTTYPE);

// Definir os pinos da célula de carga e motor de passo
#define LOADCELL_DOUT_PIN 25
#define LOADCELL_SCK_PIN 26

// Definir os pinos do ULN2003 conectados ao ESP32
#define IN1 14
#define IN2 12
#define IN3 13
#define IN4 33

// Configuração do motor de passo
const int stepsPerRevolution = 2048;  // Passos por rotação do 28BYJ-48
Stepper stepper(stepsPerRevolution, IN1, IN3, IN2, IN4);  // Definindo a ordem dos pinos

// Configuração do display OLED
#define SCREEN_WIDTH 128  // Largura do display OLED
#define SCREEN_HEIGHT 64  // Altura do display OLED
#define OLED_RESET    -1  // Pino de reset (não utilizado neste display)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

HX711 scale;

// Variáveis para armazenar a temperatura e umidade
float temperatura;
float humidade;
const int ledPin = 5;



float calibration_factor = -1057;  // Fator de calibração ajustado
float target_weight = 15.0;        // Peso desejado em gramas
float current_weight = 0;          // Peso atual lido
float previous_weight = 0;         // Armazena o peso anterior para evitar ações repetitivas
bool manual_motor_control = false; // Flag para controle manual do motor

// Credenciais WiFi (configuradas via menuconfig)
char ssid[] = CONFIG_WIFI_SSID;
char pass[] = CONFIG_WIFI_PASSWORD;

// Função para desativar as bobinas do motor de passo
void desativarMotor() {
digitalWrite(IN1, LOW);
digitalWrite(IN2, LOW);
digitalWrite(IN3, LOW);
digitalWrite(IN4, LOW);
}



// Variável para armazenar o estado do botão Blynk
int displayOption = 0;

// Bitmap do logotipo (substitua isso com o seu próprio bitmap)
const unsigned char myLogo [] = {

    
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x10, 0x04, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x18, 0x0c, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x18, 0x04, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x10, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x01, 0xe0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0xc0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x40, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x40, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x81, 0x20, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe6, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0x03, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x7f, 0xf1, 0xc7, 0xff, 0xf8, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0x03, 0xff, 0xff, 0xfe, 0x7f, 0xf0, 0x3f, 0xf1, 0xc7, 0xff, 0x3f, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0x3f, 0xff, 0xff, 0xfe, 0x7f, 0xe3, 0x1f, 0xf1, 0xc7, 0xff, 0x3f, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0x3f, 0x8f, 0x07, 0x84, 0x1f, 0xe7, 0x9f, 0xf0, 0xc7, 0x06, 0x0c, 0xe1, 0xff, 0xff, 
    0xff, 0xff, 0x3f, 0x27, 0x07, 0x04, 0x1f, 0xe7, 0x8f, 0xf0, 0x87, 0x06, 0x08, 0xc0, 0xff, 0xff, 
    0xff, 0xff, 0x3e, 0x73, 0xf2, 0x7e, 0x7f, 0xe7, 0x8f, 0xf0, 0x87, 0xe3, 0x38, 0xcf, 0xff, 0xff, 
    0xff, 0xff, 0x06, 0x73, 0xf2, 0x3e, 0x78, 0x67, 0x88, 0x32, 0x87, 0xf3, 0x38, 0x8f, 0xff, 0xff, 
    0xff, 0xff, 0x06, 0x03, 0x03, 0x0e, 0x70, 0x67, 0x88, 0x32, 0xa3, 0x03, 0x38, 0x8f, 0xff, 0xff, 
    0xff, 0xff, 0x3e, 0x02, 0x23, 0x86, 0x7f, 0xe7, 0x8f, 0xf2, 0x32, 0x23, 0x38, 0x8f, 0xff, 0xff, 
    0xff, 0xff, 0x3e, 0x7e, 0x73, 0xe2, 0x7f, 0xe7, 0x9f, 0xe2, 0x32, 0x73, 0x38, 0x8f, 0xff, 0xff, 
    0xff, 0xff, 0x3e, 0x7e, 0x63, 0xe2, 0x7f, 0xe3, 0x9f, 0xe2, 0x32, 0x63, 0x38, 0xcf, 0xff, 0xff, 
    0xff, 0xff, 0x3f, 0x02, 0x02, 0x06, 0x1f, 0xf0, 0x3f, 0xe7, 0xf2, 0x03, 0x0c, 0xc0, 0xff, 0xff, 
    0xff, 0xff, 0x3f, 0x87, 0x1b, 0x0f, 0x0f, 0xf8, 0x7f, 0xe7, 0xf3, 0x1b, 0x8c, 0xe1, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};


void showLogo() {
display.clearDisplay(); 
display.drawBitmap(0, 0, myLogo, 128, 64, WHITE);  // Desenha o logotipo no display
display.display();  // Atualiza o display
delay(3000);  // Mantém o logotipo visível por 3 segundos
}

static bool diagnostic()
{
    return true; /* Currently only a placeholder */
}


extern "C" void app_main()
{
    const esp_partition_t *running = esp_ota_get_running_partition();
    esp_ota_img_states_t ota_state;

    if (esp_ota_get_state_partition(running, &ota_state) == ESP_OK) {
        if (ota_state == ESP_OTA_IMG_PENDING_VERIFY) {
            // run diagnostic function ...
            bool diagnostic_is_ok = diagnostic();
            if (diagnostic_is_ok) {
                ESP_LOGI(TAG, "Diagnostics completed successfully! Continuing execution ...");
                esp_ota_mark_app_valid_cancel_rollback();
            } else {
                ESP_LOGE(TAG, "Diagnostics failed! Start rollback to the previous version ...");
                esp_ota_mark_app_invalid_rollback_and_reboot();
            }
        }
    }
    
    // Initialize NVS.
    esp_err_t err = nvs_flash_init();
    if (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        // 1.OTA app partition table has a smaller NVS partition size than the non-OTA
        // partition table. This size mismatch may cause NVS initialization to fail.
        // 2.NVS partition contains data in new format and cannot be recognized by this version of code.
        // If this happens, we erase NVS partition and initialize NVS again.
        ESP_ERROR_CHECK(nvs_flash_erase());
        err = nvs_flash_init();
    }
    ESP_ERROR_CHECK(err);

    ESP_ERROR_CHECK(esp_event_loop_create_default());


    initArduino();


    Serial.begin(115200);  // Inicia a comunicação serial
    dht.begin();
    pinMode(ledPin, OUTPUT);
    
    // Add small delay to allow esp_event_loop to initialize properly
    vTaskDelay(100 / portTICK_PERIOD_MS);
    
    // Initialize WiFi before OTA task
    ESP_LOGI(TAG, "Connecting to WiFi: %s", ssid);
    WiFi.mode(WIFI_STA);
    WiFi.begin(ssid, pass);
    
    int wifi_attempts = 0;
    while (WiFi.status() != WL_CONNECTED && wifi_attempts < 20) {
        vTaskDelay(500 / portTICK_PERIOD_MS);
        wifi_attempts++;
        Serial.print(".");
    }
    
    if (WiFi.status() == WL_CONNECTED) {
        ESP_LOGI(TAG, "WiFi connected. IP: %s", WiFi.localIP().toString().c_str());
    } else {
        ESP_LOGW(TAG, "WiFi connection failed after %d attempts", wifi_attempts);
    }
    
    // Inicializar o display OLED
    if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {  // Endereço I2C 0x3C para o display OLED
        Serial.println(F("Falha ao inicializar o display OLED"));
        for(;;);
    }

    // Exibe o logotipo durante o carregamento
    showLogo();
    
    display.clearDisplay();
    display.setTextSize(1.5);
    display.setTextColor(WHITE);
    display.setCursor(0, 0);
    display.println("Sistema Iniciado");
    display.display();

    // Iniciar a célula de carga
    scale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN);
    scale.set_scale(calibration_factor);
    scale.tare();  // Zera a balança com a tigela vazia

    // Configurar a velocidade do motor de passo
    stepper.setSpeed(10);  // Velocidade em rotações por minuto (RPM)
    
    Serial.println("Sistema pronto. Coloque a tigela vazia.");
    display.clearDisplay();
    display.setCursor(0, 0);
    display.println("Pronto. Coloque a tigela.");
    display.display();

    /**
     * Start FreeRTOS tasks
     */
    xTaskCreate(&ota_task, "ota_task", 12288, NULL, tskIDLE_PRIORITY + 1, NULL);

    mqtt_app_start();

    ESP_LOGI(TAG, "Setup done, entering loop");

    for(;;) {  // Loop principal
        // Only execute main loop if OTA is not running
        if (xSemaphoreTake(ota_semaphore, 0) == pdTRUE) {
            xSemaphoreGive(ota_semaphore);  // Immediately release
            
        // Ler o peso atual da célula de carga
        current_weight = scale.get_units();  
        
        // Exibir o peso atual no monitor serial e no display OLED
        Serial.print("Peso lido: ");
        Serial.print(current_weight, 2);
        Serial.println(" g");

        if (displayOption == 0) {
            humidade = dht.readHumidity(); // Lê a umidade
            temperatura = dht.readTemperature(); // Lê a temperatura em Celsius
            if (mqtt_client != NULL) {
                char temp_buffer[50];
                snprintf(temp_buffer, sizeof(temp_buffer), "%.1f", temperatura);
                esp_mqtt_client_publish(mqtt_client, "test", temp_buffer, 0, 0, 0);
            }

            // Mostra os dados no OLED
        if (isnan(temperatura) || isnan(humidade)) {
            display.println("Erro ao ler DHT11");
            } else {
            display.clearDisplay();
            display.setCursor(0, 0);
            display.println("Sensor DHT11:");
            display.print("Temperatura: ");
            display.print(temperatura);
            display.println(" C");
            display.print("Humidade: ");
            display.print(humidade);
            display.println(" %");
            }
        } else {

        display.clearDisplay();
        display.setCursor(0, 0);
        display.println("Peso atual:");
        display.setCursor(0, 20);
        display.print(current_weight, 2);
        display.println(" g");

        }

        // Controle automático baseado no peso
        if (!manual_motor_control) {  // Verifica se o controle manual está desativado
            if (current_weight < target_weight) {
            if (previous_weight != current_weight) {  // Executa apenas se o peso mudou
                for(int dutyCycle = 0; dutyCycle <= 255; dutyCycle++){   
                // changing the LED brightness with PWM
                analogWrite(ledPin, dutyCycle);
                
                }

                // decrease the LED brightness
                for(int dutyCycle = 255; dutyCycle >= 0; dutyCycle--){
                // changing the LED brightness with PWM
                analogWrite(ledPin, dutyCycle);
                
                }

                stepper.step(-2048);  // Gira o motor para dispensar comida
                stepper.step(256);    // Ajusta o motor de volta
                previous_weight = current_weight;  // Atualiza o peso anterior
                //display.setCursor(0, 40);
                //display.println("Dispensando comida...");
                //display.display();  // Atualiza o conteúdo do display OLED
            }
            } else {
            display.setCursor(0, 40);
            //display.println("Peso alvo atingido.");
            Serial.println("Peso alvo atingido! Motor parado.");
            desativarMotor();   // Desativa o motor após atingir o peso alvo
            }
        }

        display.display();  // Atualiza o conteúdo do display OLED
} else {
            // OTA is running, skip main operations and sleep
            ESP_LOGD(TAG, "OTA in progress, main loop sleeping");
        }
        vTaskDelay(500 / portTICK_PERIOD_MS);  // Aguardar meio segundo antes da próxima leitura
    }


    // WARNING: if program reaches end of function app_main() the MCU will restart ????????
}